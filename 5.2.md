Antonio Caro Benítez  
24/01/2025  
1º DAW B  
Entornos De Desarrollo, Unidad 5, Práctica 5.2

# Sistema de Gestión de Pedidos

## a) Lista de conceptos del diagrama UML que se asemejan a los conceptos de POO

1. **Clases**:
   - `Cliente`: Representa a los clientes que realizan pedidos.
   - `Pedido`: Representa los pedidos realizados por los clientes.
   - `Producto`: Representa los productos que se incluyen en los pedidos.
   - `Pago`: Representa los pagos asociados a un pedido.
   - `DetallePedido`: Representa la relación entre un pedido y los productos que contiene.

2. **Atributos**:
   - `Cliente`: `id`, `nombre`, `direccion`, `telefono`.
   - `Pedido`: `id`, `fecha`, `estado`, `total`.
   - `Producto`: `id`, `nombre`, `descripcion`, `precio`, `impuestos`.

4. **Métodos**:
   - `Pedido`: `calcularTotal()`.
   - `DetallePedido`: `calcularSubtotal()`.
   - `Pago`: `realizarPago()`.

6. **Relaciones**:
   - **Asociación**: Un `Cliente` realiza uno o varios `Pedidos`.
   - **Composición**: Un `Pedido` contiene uno o varios `DetallePedido`, y cada `DetallePedido` está asociado a un `Producto`.
   - **Agregación**: Un `Pedido` puede tener uno o varios `Pagos`.

7. **Herencia**:
   - `Pago` es una clase base, y puede tener subtipos como `Tarjeta`, `Efectivo` y `Cheque`.

8. **Estados**:
   - El atributo `estado` en `Pedido` representa los diferentes estados por los que puede pasar un pedido (`pdte`, `pgdo`, `pcdo`, `envdo`, `entgdo`).

---

## b) Explicación de la herramienta utilizada para generar el diagrama UML

**Herramienta utilizada**: **Draw.io (diagrams.net)**.

**Porque he elegido Draw.io**:
- Draw.io es una herramienta gratuita y no requiere instalación, ya que se puede usar directamente en el navegador.
- Tiene una interfaz intuitiva y permite crear diagramas UML rápidamente.
- Permite guardar diagramas en la nube (Google Drive, OneDrive) o localmente, lo que facilita el trabajo en equipo.
- Los diagramas se pueden exportar en múltiples formatos (PNG, JPEG, PDF, XML, etc.).
- Draw.io soporta la creación de diagramas UML, incluyendo clases, relaciones, herencia, etc.

**Contraste con otras herramientas**:
- **Lucidchart**: Es una herramienta similar, pero tiene limitaciones en su versión gratuita.
- **StarUML**: Es una herramienta más especializada para UML, pero es de pago y menos intuitiva para usuarios ocasionales.
- **Visual Paradigm**: Es muy completa, pero también es de pago y puede ser abrumadora para proyectos pequeños.

**Conclusión**: Draw.io es ideal para proyectos pequeños o medianos, donde se necesita una herramienta rápida, gratuita y fácil de usar. Para proyectos más complejos, se podría considerar StarUML o Visual Paradigm.

---

## c) Conversión del diagrama UML a código en Kotlin

### Explicación de la conversión:

- **Clases**: Cada clase del diagrama UML se convierte en una clase en Kotlin.

- **Atributos**: Los atributos de las clases UML se traducen en propiedades de las clases Kotlin.

- **Métodos**: Los métodos de las clases UML se implementan como funciones en Kotlin.

- **Relaciones**:
  - La relación "Cliente realiza Pedido" se implementa mediante el método `realizarPedido()`.
  - La relación "Pedido contiene Producto" se implementa mediante una lista de pares `(Producto, Int)`.
  - La relación "Pago tiene FormaPago" se implementa mediante una propiedad `formaPago` en la clase `Pago`.

- **Herencia**: La clase abstracta `FormaPago` se extiende en `Tarjeta`, `Efectivo` y `Cheque`.

Este código en Kotlin es una implementación directa del diagrama UML, respetando los principios de la POO.

```kotlin
class Cliente(
    val id: Int,
    val nombre: String,
    val direccion: String,
    val telefono: String
) {
    // Métodos adicionales pueden ir aquí
}

class Pedido(
    val idPedido: Int,
    val fecha: String,
    var estado: String = "pdte", // Estado inicial: pendiente
    var costeTotal: Double = 0.0
) {
    private val productos: MutableList<Pair<Producto, Int>> = mutableListOf()

    fun agregarProducto(producto: Producto, cantidad: Int) {
        productos.add(producto to cantidad)
        costeTotal += producto.precio * cantidad
    }

    fun calcularCosteTotal(): Double {
        return productos.sumOf { (producto, cantidad) -> producto.precio * cantidad }
    }

    fun actualizarEstado(nuevoEstado: String) {
        estado = nuevoEstado
    }
}

class Producto(
    val idProducto: Int,
    val nombre: String,
    val descripcion: String,
    val precio: Double,
    val impuestos: Double,
    var stock: Int
) {
    fun actualizarStock(cantidad: Int) {
        stock += cantidad
    }
}

class Pago(
    val idPago: Int,
    val monto: Double,
    val fecha: String,
    val formaPago: FormaPago
) {
    fun registrarPago() {
        println("Pago registrado: $monto")
    }
}

abstract class FormaPago(val tipo: String) {
    abstract fun procesarPago()
}

class Tarjeta(
    val numeroTarjeta: String,
    val fechaCaducidad: String,
    val tipoTarjeta: String
) : FormaPago("Tarjeta") {
    override fun procesarPago() {
        println("Procesando pago con tarjeta $numeroTarjeta")
    }
}

class Efectivo(
    val tipoMoneda: String
) : FormaPago("Efectivo") {
    override fun procesarPago() {
        println("Procesando pago en efectivo en $tipoMoneda")
    }
}

class Cheque(
    val nombreEmisor: String,
    val banco: String
) : FormaPago("Cheque") {
    override fun procesarPago() {
        println("Procesando pago con cheque de $nombreEmisor ($banco)")
    }
}
